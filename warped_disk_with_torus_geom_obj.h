//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//    Version 1.0; svn revision $LastChangedRevision: 1097 $
//LIC//
//LIC// $LastChangedDate: 2015-12-17 11:53:17 +0000 (Thu, 17 Dec 2015) $
//LIC// 
//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_CYLINDRICALLY_WARPED_GEOM_OBJ_WITH_BOUNDARY_HEADER
#define OOMPH_CYLINDRICALLY_WARPED_GEOM_OBJ_WITH_BOUNDARY_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


//oomph-lib headers
//#include "geom_objects.h"

#include "generic/geom_obj_with_boundary.h"
#include "additional_maths.h"

namespace oomph
{
  // x-y projection of a flat circle of radius R_circle which is rolled
  // around a cylinder with an axis of rotation parallel with the
  // y-axis and with radius R_curvature
  class XYProjectionOfCylindricallyWarpedCircle :
    public virtual GeomObject
  {
    
  public:
    
  XYProjectionOfCylindricallyWarpedCircle(const double& r_circle,
					  const double& r_curvature)
    : GeomObject(1,2), R_circle(r_circle), R_curvature(r_curvature) { }

    void position(const Vector<double>& xi, Vector<double>& r) const
    {
      r[0] = R_curvature * sin( R_circle * cos(xi[0]) / R_curvature);
      r[1] = R_circle * sin(xi[0]);
    }
    
  private:

    double R_circle;
    double R_curvature;
    
  };
  
  //=========================================================================
  /// \short Warped disk in 3d: zeta[0]=x; zeta[1]=y (so it doesn't have 
  /// coordinate singularities), with specification of two boundaries (b=0,1)
  /// that turn the whole thing into a circular disk. 
  //=========================================================================
  class CylindricallyWarpedCircularDisk : public DiskLikeGeomObjectWithBoundaries
  {

  public:

    /// Constructor. Pass amplitude and azimuthal wavenumber of
    /// warping as arguments. Can specify vertical offset as final, optional
    /// argument.
  CylindricallyWarpedCircularDisk(const double& radius_of_curvature) :
    R(radius_of_curvature)
    {
      // How many boundaries do we have?
      unsigned nb = 2;
      Boundary_parametrising_geom_object_pt.resize(nb);
      Zeta_boundary_start.resize(nb,0.0);
      Zeta_boundary_end.resize(nb,0.0);

      // GeomObject<1,2> representing the first boundary
      Boundary_parametrising_geom_object_pt[0] = new Ellipse(1.0, 1.0);
	/* new XYProjectionOfCylindricallyWarpedCircle(1.0, radius_of_curvature); */
      Zeta_boundary_start[0] = 0.0;
      Zeta_boundary_end[0] = MathematicalConstants::Pi;

      // GeomObject<1,2> representing the second boundary
      Boundary_parametrising_geom_object_pt[1] = new Ellipse(1.0, 1.0);
	/* new XYProjectionOfCylindricallyWarpedCircle(1.0, radius_of_curvature); */
      Zeta_boundary_start[1] = MathematicalConstants::Pi;
      Zeta_boundary_end[1] = 2.0*MathematicalConstants::Pi;

    }

    /// Empty default constructor.
    CylindricallyWarpedCircularDisk()
    {
      throw OomphLibError("Don't call default constructor!",
			  OOMPH_CURRENT_FUNCTION,
			  OOMPH_EXCEPTION_LOCATION);
    }


    /// Broken copy constructor
    CylindricallyWarpedCircularDisk(const CylindricallyWarpedCircularDisk& dummy) 
    { 
      BrokenCopy::broken_copy("CylindricallyWarpedCircularDisk");
    } 
 
    /// Broken assignment operator
    void operator=(const CylindricallyWarpedCircularDisk&) 
      {
	BrokenCopy::broken_assign("CylindricallyWarpedCircularDisk");
      }

    /// Destructor
    virtual ~CylindricallyWarpedCircularDisk()
    {
      unsigned n = nboundary();
      for (unsigned b=0; b<n; b++)
      {
	delete Boundary_parametrising_geom_object_pt[b];
	Boundary_parametrising_geom_object_pt[b] = 0;
      }
    }

    /// Access fct to radius of curvature of disk warping
    double& radius_of_curvature()
    {
      return R;
    }
 
    /// \short Eulerian position Vector at Lagrangian coordinates xi 
    void position(const LagrangianCoordinates& xi, Vector<double>& r) const
    {
      // get polar coords
      const double xi1 = xi.xi1;
      const double xi2 = xi.xi2;
   
      const double x0 = xi1 * cos(xi2);

      r[0] = R * sin(x0/R);
      r[1] = xi1 * sin(xi2);
      r[2] = R - R * sqrt(1.0 - pow(sin(x0/R),2));
    }
  
    void position(const Vector<double>& x, Vector<double>& r) const
    {
      const double xi1 = sqrt(x[0]*x[0] + x[1]*x[1]);
      const double xi2 = atan2(x[1], x[0]);

      LagrangianCoordinates lagr_coords(xi1, xi2, 0.0);
      position(lagr_coords, r);      
    }

    /// \short Parametrised position on object: r(zeta). Evaluated at
    /// previous timestep. t=0: current time; t>0: previous
    /// timestep. Object is steady so calls time-independent version
    void position(const unsigned& t, const Vector<double>& x, 
		  Vector<double>& r) const
    {
      position(x, r);
    }

    void dposition_dxi(const LagrangianCoordinates& lagr_coords, DenseMatrix<double>& dr_dxi)
    {
      // shorthand
      const double xi1 = lagr_coords.xi1;
      const double xi2 = lagr_coords.xi2;
	
      dr_dxi.resize(3, 2, 0.0);

      // dr_x/dxi_1
      dr_dxi(0,0) = 
	Cos(xi2)*Cos((xi1*Cos(xi2))/R);
	
      // dr_x/dxi_2
      dr_dxi(0,1) = -(xi1*Cos((xi1*Cos(xi2))/R)*Sin(xi2));

      // dr_y/dx_1
      dr_dxi(1,0) = Sin(xi2);

      // dr_y/dxi_2
      dr_dxi(1,1) = xi1*Cos(xi2);;

      // dr_z/dxi_1
      dr_dxi(2,0) = (xi1*Power(Cos(xi2),2))/
	Sqrt(Power(R,2) - Power(xi1,2)*Power(Cos(xi2),2));

      // dr_z/dxi_2
      dr_dxi(2,1) = -((Power(xi1,2)*Cos(xi2)*Sin(xi2))/
		      Sqrt(Power(R,2) - Power(xi1,2)*Power(Cos(xi2),2)));
      
    }
    
    // compute the basis vectors a_i(\xi_1, \xi_2) = dr/dxi_i
    void basis_vectors(const LagrangianCoordinates& lagr_coords,
		       Vector<double>& a1,
		       Vector<double>& a2,
		       Vector<double>& a3) const
    {
      // shorthand interpretation
      const double xi1 = lagr_coords.xi1;
      const double xi2 = lagr_coords.xi2;

      const double x0 = xi1 * cos(xi2);
   
      // make enough space
      a1.resize(3, 0.0);
      a2.resize(3, 0.0);
      a3.resize(3, 0.0);

      // dr/dxi_1
      a1[0] = cos(xi2) * cos(x0/R);
      a1[1] = sin(xi2);
      a1[2] = cos(xi2) * sin(x0/R);

      // dr/dxi_2
      a2[0] = -xi1 * sin(xi2) * cos(x0/R);
      a2[1] = xi1 * cos(xi2);
      a2[2] = -xi1 * sin(xi2) * sin(x0/R);

      // a3 = a1 ^ a2
      a3[0] = -xi1 * sin(x0/R);
      a3[1] = 0;
      a3[2] = xi1 * cos(x0/R);

      // normalise the basis vectors
      // ----------------------------------------
      double norm = VectorHelpers::magnitude(a1);
      for(double& ai : a1)
	ai /= norm;

      norm = VectorHelpers::magnitude(a2);
      for(double& ai : a2)
	ai /= norm;

      norm = VectorHelpers::magnitude(a3);
      for(double& ai : a3)
	ai /= norm;
    }

    // compute the derivatives of the basis vectors w.r.t. the two
    // curvilinear coordinates defining the disk surface
    void da_dxi(const LagrangianCoordinates& lagr_coords,
		DenseMatrix<double>& da1_dxi,
		DenseMatrix<double>& da2_dxi,
		DenseMatrix<double>& da3_dxi)
    {
      const double xi1 = lagr_coords.xi1;
      const double xi2 = lagr_coords.xi2;

      // make space; matrices are really 3x2: da_{x,y,z}/dxi_{1,2}
      // adding third column to prevent indexing issues wherever this is called,
      // but da/dxi3 = 0 by definition of {xi_j}
      da1_dxi.resize(3, 3, 0.0);
      da2_dxi.resize(3, 3, 0.0);
      da3_dxi.resize(3, 3, 0.0);
   
      // ====================
      // da_1
      // ====================

      // da_1/dxi_1
      // ---------
  
      // da1_x/dxi_1
      da1_dxi(0,0) = -((pow(cos(xi2),2)*sin((xi1*cos(xi2))/R))/R);

      // da1_y/dxi_1
      da1_dxi(1,0) = 0.0;

      // da1_z/dxi_1
      da1_dxi(2,0) = (pow(cos(xi2),2)*cos((xi1*cos(xi2))/R))/R;

      // da_1/dxi_2
      // ----------
  
      // da1_x/dxi_2
      da1_dxi(0,1) = sin(xi2)*(-cos((xi1*cos(xi2))/R) + 
			       (xi1*cos(xi2)*sin((xi1*cos(xi2))/R))/R);

      // da1_y/dxi_2
      da1_dxi(1,1) = cos(xi2);
   
      // da1_z/dxi_2
      da1_dxi(2,1) = -((sin(xi2)*(xi1*cos(xi2)*cos((xi1*cos(xi2))/R) + R*sin((xi1*cos(xi2))/R)))/
		       R);
   
      // ====================
      // da_2
      // ====================
  
      // da_2/dxi_1
      // ---------
  
      // da2_x/dxi_1
      da2_dxi(0,0) = (Cos(xi2)*Sin(xi2)*Sin((xi1*Cos(xi2))/R))/R;

      // da2_y/dxi_1
      da2_dxi(1,0) = 0.0;

      // da2_z/dxi_1
      da2_dxi(2,0) = -((Cos(xi2)*Cos((xi1*Cos(xi2))/R)*Sin(xi2))/R);

      // da_2/dxi_2
      // ----------
   
      // da2_x/dxi_2
      da2_dxi(0,1) = -((R*Cos(xi2)*Cos((xi1*Cos(xi2))/R) +
			xi1*Power(Sin(xi2),2)*Sin((xi1*Cos(xi2))/R))/R);

      // da2_y/dxi_2
      da2_dxi(1,1) = -Sin(xi2);
   
      // da2_z/dxi_2
      da2_dxi(2,1) = (xi1*Cos((xi1*Cos(xi2))/R)*Power(Sin(xi2),2))/R -
	Cos(xi2)*Sin((xi1*Cos(xi2))/R);

      // ====================
      // da_3
      // ====================

      // da_3/dxi_1
      // ---------
  
      // da3_x/dxi_1
      da3_dxi(0,0) = -((Cos(xi2)*Cos((xi1*Cos(xi2))/R))/R);
   
      // da3_y/dxi_1
      da3_dxi(1,0) = 0.0;

      // da3_z/dxi_1
      da3_dxi(2,0) = -((Cos(xi2)*Sin((xi1*Cos(xi2))/R))/R);
   
      // da_3/dxi_2
      // ----------

      // da3_x/dxi_2
      da3_dxi(0,1) = (xi1*Cos((xi1*Cos(xi2))/R)*Sin(xi2))/R;

      // da3_y/dxi_2
      da3_dxi(1,1) = 0.0;
   
      // da3_z/dxi_2
      da3_dxi(2,1) = (xi1*Sin(xi2)*Sin((xi1*Cos(xi2))/R))/R;
    }

    /// Boundary triad on boundary b at boundary coordinate zeta_bound
    void boundary_triad(const unsigned& b,
			const double& zeta_bound,
			Vector<double>& r,
			Vector<double>& tangent,
			Vector<double>& normal,
			Vector<double>& binormal)
    {      
      LagrangianCoordinates lagr_coords(1, zeta_bound, 0.0);
      
      // get the Eulerian position
      position(lagr_coords, r);

      // and get the triad vectors
      basis_vectors(lagr_coords, normal, tangent, binormal);
    }
    
    /// \short Output triad derivatives at nplot plot points. Streams:
    /// - boundary_tangent_file : x, y, z, dtxi_dxj
    /// - boundary_normal_file  : x, y, z, dsi_dxj
    /// - boundary_binormal_file: x, y, z, dni_dxj
    void output_dboundary_triad_dx_csv(const unsigned& nplot,
				       std::ofstream& boundary_dtangent_dx_file,
				       std::ofstream& boundary_dnormal_dx_file,
				       std::ofstream& boundary_dbinormal_dx_file)
    {
      std::ostringstream error_message;
      error_message << "Output_dboundary_triad_dx_csv() currently broken\n\n";

      throw OomphLibError(error_message.str(),
			  OOMPH_CURRENT_FUNCTION,
			  OOMPH_EXCEPTION_LOCATION);
   
      Vector<double> r(3);
      Vector<double> zeta(2);
      double zeta_bound = 0.0;
   
      DenseMatrix<double> dtangent_dx(3);
      DenseMatrix<double> dnormal_dx(3);
      DenseMatrix<double> dbinormal_dx(3);

      boundary_dtangent_dx_file <<
	"x,y,z,dtx_dx,dtx_dy,dtx_dz,dty_dx,dty_dy,dty_dz,dtz_dx,dtz_dy,dtz_dz\n";

      boundary_dnormal_dx_file <<
	"x,y,z,dsx_dx,dsx_dy,dsx_dz,dsy_dx,dsy_dy,dsy_dz,dsz_dx,dsz_dy,dsz_dz\n";

      boundary_dbinormal_dx_file <<
	"x,y,z,dnx_dx,dnx_dy,dnx_dz,dny_dx,dny_dy,dny_dz,dnz_dx,dnz_dy,dnz_dz\n";
   
      unsigned nb = nboundary();
      for (unsigned b=0; b<nb; b++)
      {
	double zeta_min = zeta_boundary_start(b);
	double zeta_max = zeta_boundary_end(b);
	unsigned n = 20;
	for (unsigned i=0; i<n; i++)
	{
	  zeta_bound = zeta_min+
	    (zeta_max-zeta_min) * double(i) / double(n-1);
       
	  position_on_boundary(b, zeta_bound, r);  
	  zeta_on_boundary(b, zeta_bound, zeta);     
	  /* dboundary_triad_dx(b, zeta_bound, dtangent_dx, dnormal_dx, dbinormal_dx); */

	  boundary_dtangent_dx_file << r[0] << "," 
				    << r[1] << "," 
				    << r[2] << ",";
	  for(unsigned m=0; m<3; m++)
	  {
	    for(unsigned n=0; n<3; n++)
	    {
	      boundary_dtangent_dx_file << dtangent_dx(m,n) << ",";
	    }
	  }
	  boundary_dtangent_dx_file << std::endl;

	  boundary_dnormal_dx_file << r[0] << "," 
				   << r[1] << "," 
				   << r[2] << ",";
	  for(unsigned m=0; m<3; m++)
	  {
	    for(unsigned n=0; n<3; n++)
	    {
	      boundary_dnormal_dx_file << dnormal_dx(m,n) << ",";
	    }
	  }
	  boundary_dnormal_dx_file << std::endl;
       
	  boundary_dbinormal_dx_file << r[0] << "," 
				     << r[1] << "," 
				     << r[2] << ",";
	  for(unsigned m=0; m<3; m++)
	  {
	    for(unsigned n=0; n<3; n++)
	    {
	      boundary_dbinormal_dx_file << dbinormal_dx(m,n) << ",";
	    }
	  }
	  boundary_dbinormal_dx_file << std::endl;
	}
      }
    }

 
  private:
  
    /// Radius of curvature (x-z plane)
    double R;
  };

  /////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////

  //=========================================================================
  /// \short Warped disk in 3d: zeta[0]=x; zeta[1]=y (so it doesn't have 
  /// coordinate singularities), with specification of two boundaries (b=0,1)
  /// that turn the whole thing into a circular disk. In addition
  /// has two internal boundaries (b=2,3), a distance h_annulus from 
  /// the outer edge. Annual (outer) region is region 1.
  //=========================================================================
  class CylindricallyWarpedCircularDiskWithAnnularInternalBoundary : 
    public virtual CylindricallyWarpedCircularDisk
  {

  public:

    /// Constructor. Pass radius of internal boundary and the
    /// (cylindrical) radius of curvature as arguments
    CylindricallyWarpedCircularDiskWithAnnularInternalBoundary
      (const double& h_annulus,
       const double& radius_of_curvature) :
    CylindricallyWarpedCircularDisk(radius_of_curvature), H_annulus(h_annulus)
    {  
      // We have two more boundaries!
      Boundary_parametrising_geom_object_pt.resize(4);
      Zeta_boundary_start.resize(4);
      Zeta_boundary_end.resize(4);

      // Radius of the internal annular boundary
      double r_annulus = 1.0-h_annulus;

      // GeomObject<1,2> representing the third boundary
      Boundary_parametrising_geom_object_pt[2] = new Ellipse(r_annulus,r_annulus);
	/* new XYProjectionOfCylindricallyWarpedCircle(r_annulus, radius_of_curvature); */
      Zeta_boundary_start[2] = 0.0;
      Zeta_boundary_end[2] = MathematicalConstants::Pi;

      // GeomObject<1,2> representing the fourth boundary
      Boundary_parametrising_geom_object_pt[3] = new Ellipse(r_annulus,r_annulus);
	/* new XYProjectionOfCylindricallyWarpedCircle(r_annulus, radius_of_curvature); */
      Zeta_boundary_start[3] = MathematicalConstants::Pi;
      Zeta_boundary_end[3] = 2.0*MathematicalConstants::Pi;

      // Region 1 is the annular region; identify it by a point in 
      // this region. 
      unsigned r = 1;
      Vector<double> zeta_in_region(2);
      zeta_in_region[0] = 0.0;
      zeta_in_region[0] = 1.0-0.5*h_annulus;
      add_region_coordinates(r,zeta_in_region);
    }

    /// Broken copy constructor
    CylindricallyWarpedCircularDiskWithAnnularInternalBoundary
      (const CylindricallyWarpedCircularDiskWithAnnularInternalBoundary& dummy) 
    { 
      BrokenCopy::broken_copy("CylindricallyWarpedCircularDiskWithAnnularInternalBoundary");
    } 
 
    /// Broken assignment operator
    void operator=(const CylindricallyWarpedCircularDiskWithAnnularInternalBoundary&) 
      {
	BrokenCopy::broken_assign("CylindricallyWarpedCircularDiskWithAnnularInternalBoundary");
      }

    /// Destructor (empty; cleanup happens in base class)
    virtual ~CylindricallyWarpedCircularDiskWithAnnularInternalBoundary()
    {}


    /// \short Thickness of annular region (distance of internal boundary
    /// from outer edge of unit circle)
    double h_annulus() const
    {
      return H_annulus;
    }

  protected:

    /// \short Thickness of annular region (distance of internal boundary
    /// from outer edge of unit circle)
    double H_annulus;


  };


}

#endif
